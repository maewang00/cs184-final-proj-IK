<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 50px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1 {
    font-family: 'Times New Roman', sans-serif;
    font-size: 38px;
    line-height: 30px;
  }
  h2, h3, h4 {
    font-family: 'Times New Roman', sans-serif;
    line-height: 30px;
  }

  p {
    font-family: 'Times New Roman', sans-serif;
    padding-bottom: 10px; 
    font-size: 20px;
    line-height: 40px;
  }
</style>

<title>CS 184 Project Proposal</title>

<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>
<body>
<h1 align="middle">CS 184: Computer Graphics and Imaging, Fall 2020</h1>
<h1 align="middle">CS 184 Final Project: Proposal</h1>
<br>
<h1 align="middle">Inverse Kinematics for 3D Skeletal Control</h1>
<p align="middle">
	Mae Wang, Jason Xu, and Yowsean Li
</p>

<div align="middle"><img src="images/MecanimIKGrabbing.jpg" align= "middle" width="1000px"/></div>

<br><br>

<h2 align="middle">Summary</h2>
    <p>
      A path-defined 3D robotic simulation utilizing inverse kinematics as a physics-based animation tool. The inverse kinematics function defines joint angles to achieve a desired skeletal pose, position, or rotation in a three-dimensional space to generate realistic movements. We will develop and implement on the Unity3D platform, overriding (and potentially improving) the development engine's current built-in functions for inverse kinematics.
    </p>
<br><br>

<!------------------------------------------------------------------------------------------------------------------------------------->
<h1 align="middle">Section I: Problem Description</h1><br>

<p>Our topic involves implementing inverse kinematics (IK) on a real-time development platform to simulate movement for an articulated skeleton robot. 
</p>
<p>
With this mechanism implemented, we will be able to define animation as where the skeletal system should be rather than how the system should move. This way, we can execute complex motions dynamically that are often used for real time/premade simulations and graphical games.
</p>
<p>
While there are mathematical models for inverse kinematics readily defined, anticipated challenges include transcribing these models into executable code, understanding how to use Unity3D as a visual and development platform, and including additions (e.g. machine learning-based solutions to external forces or input for stylized motion) that will make movement more realistic and robust.
</p>
<p>
Given that there are many useful resources for inverse kinematics and Unity documentation online, we will be able to understand how to implement inverse kinematics on Unity3D. For implementing additional features, reading research papers on inverse kinematics optimizations should be sufficient.
</p>

<br><br>
<!------------------------------------------------------------------------------------------------------------------------------------->
<h1 align="middle">Section II: Goals and Deliverables</h1><br>

<p>
	For this project, we plan on delivering a video demo of an animated humanoid walking using inverse kinematics.  To achieve such a result, we will develop a set of inverse kinematics APIs in Unity’s environment. Our demo will include a video of our animation and potentially a demonstration of the inverse kinematics system within Unity itself.
</p>
<p>
	Since our goal for this project is to simulate human gait, the performance of our inverse kinematics system is hard to quantify through concrete quantitative metrics. Instead, we will evaluate our project qualitatively as to whether the movements of the joints look realistic by looking at motion fluidity and anatomical feasibility. In addition, we will compare Unity’s built-in inverse kinematics system with ours to benchmark our progress. Our goal is to achieve a similar animation effect as Unity’s.
</p>
<p>
	We expect to hit several blockers along the development process including understanding Unity’s sandbox and previously unconsidered factors in calculating inverse kinematics. However, if we get ahead of schedule, as a secondary goal, we hope to achieve computationally efficient APIs. We will measure efficiency by comparing rendering times between Unity’s system and ours. In addition, we will try to achieve generalizable APIs that can account for external control dynamics like obstacles and resistance forces on the humanoid and will measure the quality similar to how we plan on measuring quality for the basic walking case.
</p>



<br><br>
<!------------------------------------------------------------------------------------------------------------------------------------->
<h1 align="middle">Section III: Schedule</h1><br>

<p>Every Monday at 6:00 PM PST or when a large blocker occurs, we will host a Zoom meeting for updates and discussion.</p>

<p><b>Deadlines:</b></p>
<ul>
	<li><p>
		<b>April 14</b>: Everyone will install and get situated with the Unity3D platform and the built-in IK functions. Understand inverse kinematics more through resources. One person will set up Unity Collaborate as our main working directory.
	</p></li>

	<li><p>
		<b>April 21</b>: Everyone will import or build a 3D robot ready to be coded. Animate humanoid using Unity built-in IK functions.
	</p></li>

	<li><p>
		<b>April 28</b>: One person will build or import a 3D (or 2D) arm as a subset of the robot for prototyping. Get started on our IK API. <b>Finish graded milestone (due).</b>
	</p></li>

	<li><p>
		<b>May 5</b>: One person will build or import an full skeleton for transitioning from prototype to finalized model. One person will build or import model environment. Finalize IK API and final presentation. If we are ahead of schedule, we can implement additions like computationally efficient and robust APIs for IK.
	</p></li>

	<li><p>
		<b>May 7</b>: <b>Final presentation due.</b>
	</p></li>

	<li><p>
		<b>May 12</b>: <b>Make final report (due)</b> and final touch ups to IK and extensions
	</p></li>
</ul>

<br><br>
<!------------------------------------------------------------------------------------------------------------------------------------->
<h1 align="middle">Section IV: Resources</h1><br>

<p>
	We will be starting from an existing piece of code/system. Unity3D provides a built-in list of functions particularly for inverse kinematics. In essense, we will reinvent and improve on these functions. <br><br>Unity IK documentation: https://docs.unity3d.com/Manual/InverseKinematics.html
</p>

<p>
	We will be using our personal computers and using Unity’s engine to make the animation. Our resource links distill into two categories: practical and theoretical information. YouTube videos for example give us a practical sense of how to approach Unity and use its platform while papers and articles give us a more solid theoretical understanding in how to calculate inverse kinematics.
</p>



<ul>
  <li><p>https://www.alanzucconi.com/2018/05/02/ik-2d-2/</p></li>
  <li><p>https://www.youtube.com/watch?v=qqOAzn05fvk</p></li>
  <li><p>https://old.cescg.org/CESCG-2002/LBarinka/paper.pdf</p></li>
  <li><p>http://www-inst.cs.berkeley.edu/~cs184/fa11/resources/ik_soln.pdf</p></li>
  <li><p>http://billbaxter.com/courses/290/html/img0.htm </p></li>
  <li><p>https://robotacademy.net.au/masterclass/inverse-kinematics-and-robot-motion/?lesson=256</p></li>
  <li><p>https://medium.com/unity3danimation/create-your-own-ik-in-unity3d-989debd86770</p></li>
  <li><p>https://www.youtube.com/watch?v=X5Z7ZJ39zAA&list=LLHNtH40gMNB9t2dMs0hhVlQ&index=2&t=7s</p></li>
</ul>
  
    
</body>
</html>


<!--<p align="middle"><pre align="middle">a^2 + b^2 = c^2</pre></p> -->